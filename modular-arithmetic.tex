\chapter{Modular arithmetic}
\epigraph[author={Carl Friedrich Gauss}]{Mathematics is the queen of the sciences and number theory is the queen of mathematics.}\SubIndex{Gauss, Carl Friedrich}

\section{Definition}

If we divide integers by \(7\), the possible remainders are
\[
0, 1, 2, 3, 4, 5, 6.
\]
For example, \(65=9 \cdot 7+2\), so the remainder is \(2\).
Two integers are \emph{congruent mod \(7\)} if they have the same remainder modulo \(7\).
So \(65\) and \(2\) are congruent mod \(7\), because \(65=9 \cdot 7 + 2\) and \(2=0 \cdot 7 + 2\).
We denote congruence modulo \(7\) as
\[
\congmod[7]{65}{2}.\Notation{b=c mod m}{\congmod[m]{b}{c}}{\(b\) is congruent to \(c\) modulo \(m\)}
\]
Sometimes we will allow ourselves a sloppy notation, where we write the remainder of \(65\) modulo \(7\) as \(\overline{65}\).\Notation{bb}{\bar{b}}{congruence class of \(b\)}
This is sloppy because the notation doesn't remind us that we are working out remainders modulo \(7\).
If we change \(7\) to some other number, we could get confused by this notation.
We will often compute remainders modulo some chosen number, say \(m\), instead of \(7\).

If we add multiples of \(7\) to an integer, we don't change its remainder modulo \(7\):
\[
\overline{65+7}=\overline{65}.
\]
Similarly, 
\[
\overline{65-7}=\overline{65}.
\]


If we add, or multiply, some numbers, what happens to their remainders?
\begin{theorem}
Take a positive integer \(m\) and integers \(a, A, b, B\).
If \(\congmod[m]{a}{A}\) and \(\congmod[m]{b}{B}\) then
\begin{align*}
a+b &\equiv A+B \pmod{m}, \\
a-b &\equiv A-B \pmod{m}, \\
\text{and } ab &\equiv AB \pmod{m}.
\end{align*}
The bar notation is more elegant.
If we agree that \(\bar{a}\) means remainder of \(a\) modulo the fixed choice of integer \(m\), we can write this as: if
\[
\bar{a}=\bar{A} \text{ and } \bar{b}=\bar{B}
\]
then
\begin{align*}
\overline{a+b}&=\overline{A+B}, \\
\overline{a-b}&=\overline{A-B}, \text{ and } \\
\overline{ab}&=\overline{AB}.
\end{align*}
\end{theorem}
\begin{example}
Note that \(\congmod[7]{9}{2}\) and \(\congmod[7]{4}{11}\), so our theorem tells us that \(\congmod[7]{9 \cdot 4}{2 \cdot 11}\).
Let's check this. 
The left hand side:
\begin{align*}
9 \cdot 4
&=
36,
\\
&=
5(7)+1,
\end{align*}
so that \(\congmod[7]{9 \cdot 4}{1}\).
The right hand side:
\begin{align*}
2 \cdot 11
&=
22,
\\
&=
3(7)+1,
\end{align*}
so that \(\congmod[7]{2 \cdot 11}{1}\).
\end{example}
So it works in this example.
Let's prove that it always works.
\begin{proof}
Since \(a-A\) is a multiple of \(m\), as is \(b-B\), note that
\[
(a+b)-(A+B)=(a-A)+(b-B)
\]
is also a multiple of \(m\), so addition works.
In the same way
\[
ab-AB=(a-A)b+A(b-B)
\]
is a multiple of \(m\).
\end{proof}

\begin{problem}{modular.arithmetic:perfect.square}
Prove by induction that every ``perfect square'', i.e. integer of the form \(n^2\), has remainder \(0, 1\) or \(4\) modulo \(8\).
\end{problem}

\begin{problem}{modular.arithmetic:nine}
Take an integer like \(243098\) and write out the sum of its digits \(2+4+3+0+9+8\).
Explain why every integer is congruent to the sum of its digits, modulo \(9\).
\end{problem}
\begin{answer}{modular.arithmetic:nine}
A 1-digit positive integer has the form \(b=b_0\) with \(0 \le b_0 \le 9\) its first digit.
A 2-digit positive integer has the form \(b=b_0+10 \, b_1\) with \(0 \le b_0,b_1 \le 9\).
In general, an \(n\)-digit positive integer has the form 
\[
b=b_0+10 \, b_1 + 10^2 \, b_2 + \dots + 10^{n-1} b_{n-1}.
\]
Modulo \(9\), \(\congmod[9]{10}{1}\), so modulo 9
\begin{align*}
\congmod[9]{b&}{b_0+10 \, b_1 + 10^2 \, b_2 + \dots + 10^{n-1} b_{n-1}},
\\
\congmod[9]{&}{b_0+b_1+b_2 + \dots + b_{n-1}}.
\end{align*}
\end{answer}

\begin{problem}{modular.arithmetic:gcd}
Take integers \(a,b,m\) with \(m \ne 0\).
Let \(d\defeq\gcd{a,b,m}\).
Prove that \(\congmod[m]{a}{b}\) just when \(\congmod[m/d]{a/d}{b/d}\).
\end{problem}

\section{Arithmetic of remainders}

We now \emph{define} an addition law on the numbers \(0,1,2,3,4,5,6\) by declaring that when we add these numbers, we then take remainder modulo \(7\).
This is \emph{not} usual addition.
To make this clear, we write the remainders with bars over them, always.
For example, we are saying that in this addition law \(\bar{3}+\bar{5}\) means \(\overline{3+5}=\overline{8}=\bar{1}\), since we are working modulo \(7\).
We adopt the same rule for subtraction, and for multiplication.
For example, modulo \(13\),
\begin{align*}
\pr{\bar{7}+\bar{9}}\pr{\overline{11}+\bar{6}}
&=
\overline{16} \cdot \overline{17},
\\
&=
\overline{13+3} \cdot \overline{13+4},
\\
&=
\overline{3} \cdot \overline{4},
\\
&=
\overline{12}.
\end{align*}
If we are daring, we might just drop all of the bars, and state clearly that we are calculating modulo some integer.
In our daring notation, modulo 17,
\begin{align*}
16 \cdot 29 - 7 \cdot 5 
&=
16 \cdot 12 - 7 \cdot 5,
\\
&=
192 - 35,
\\
&=
\pr{11\cdot 17 + 5} - \pr{2 \cdot 17 + 1},
\\
&=
5 - 1,
\\
&=
4.
\end{align*}


\begin{problem}{modular.arithmetic:examples}
Expand and simplify \(\bar{5}\cdot\bar{2} \cdot \pr{\bar{6}-\bar{9}}\) modulo \(7\).
\end{problem}

The addition and multiplication tables for remainder modulo \(5\):
\[
\begin{array}{@{}r|rrrrr@{}}
+ & 0 & 1 & 2 & 3 & 4 \\ \hline
0 & 1 & 2 & 3 & 4 & 0 \\
1 & 2 & 3 & 4 & 0 & 1 \\
2 & 3 & 4 & 0 & 1 & 2 \\
3 & 4 & 0 & 1 & 2 & 3 \\
4 & 0 & 1 & 2 & 3 & 4
\end{array}
\qquad
\begin{array}{@{}r|rrrrr@{}}
\cdot & 0 & 1 & 2 & 3 & 4 \\ \hline
    0 & 0 & 0 & 0 & 0 & 0 \\
    1 & 0 & 1 & 2 & 3 & 4 \\
    2 & 0 & 2 & 4 & 1 & 3 \\
    3 & 0 & 3 & 1 & 4 & 2 \\
    4 & 0 & 4 & 3 & 2 & 1
\end{array}
\]

\begin{problem}{modular.arithmetic:laws}
Describe laws of modular arithmetic, imitating the laws of integer arithmetic.
If we work modulo \(4\), explain why the zero divisors law fails.
Why are there no sign laws?
\end{problem}

\begin{problem}{modular.arithmetic:remainder}
Compute the remainder when dividing \(19\) into \(37^{200}\).
\end{problem}

\begin{problem}{modular.arithmetic:remainder.2}
Compute the last two digits of \(9^{2000}\).
\end{problem}

\begin{problem}{modular.arithmetic:quad.eqn}
Prove that the equation \(a^2 + b^2 = 3c^2\) has no solutions in nonzero integers \(a\), \(b\) and \(c\).
Hint: start by proving that modulo \(4\), \(a^2=0\) or \(1\).
Then consider the equation modulo 4; show that \(a\), \(b\) and \(c\) are divisible by 2. Then each of \(a^2\), \(b^2\) and \(c^2\) has a factor of 4. 
Divide through by 4 to show that there would be a smaller set of solutions to the original equation.
Apply induction.
\end{problem}

\begin{example}
To carry a remainder to a huge power, say \(2^{2005}\) modulo \(13\), we can build up the power out of smaller ones.
For example, \(2^2=4\) modulo \(13\), and therefore modulo \(13\),
\begin{align*}
2^4
&=
\pr{2^2}^2,
\\
&=4^2,
\\
&=16,
\\
&=3.
\end{align*}
Keeping track of these partial results as we go, modulo \(13\),
\begin{align*}
2^8
&=
\pr{2^4}^2,
\\
&=
3^2,
\\
&=9.
\end{align*}
We get higher and higher powers of \(2\): modulo \(13\),
\[
\begin{array}{@{}rrr@{}}
\toprule 
k & 2^k & 2^{2^k} \operatorname{mod} 13 \\
\midrule
0 & 1 & 2 \\
1 & 2 & 4 \\
2 & 4 & 3 \\
3 & 8 & 9 \\
4 & 16 & 9^2=81=3\\
5 & 32 & 3^2=9 \\
6 & 64 & 9^2=3 \\
7 & 128 & 3^2=9\\
8 & 256 & 9^2=3 \\
9 & 512 & 3^2=9 \\
10 & 1024 & 9^2=3 \\
11 & 2048 & 
\\ \bottomrule
\end{array}
\]
The last row gets into \(2^{2048}\), too large to be relevant to our problem.
We now want to write out exponent \(2005\) as a sum of powers of \(2\), by first dividing in \(1024\):
\begin{align*}
2005
&=
1024
+
981
\\
\intertext{and then dividing in the next power of 2 we can fit into the remainder,}
&= 1024 + 512 + 469,
\\
&= 1024 + 512 + 256 + 128 + 64 + 16 + 4 + 1.
\end{align*}
Then we can compute out modulo \(13\):
\begin{align*}
2^{2005}
&=
2^{1024 + 512 + 256 + 128 + 64 + 16 + 4 + 1},
\\
&=
2^{1024} 2^{512} 2^{256} 2^{128} 2^{64} 2^{16} 2^4 2^1,
\\
&=
3 \cdot 9 \cdot 3 \cdot 9 \cdot 3 \cdot 3 \cdot 3 \cdot 2,
\\
&=
\pr{3 \cdot 9}^3 \cdot 2,
\\
&=
27^2 \cdot 2,
\\
&=
1^2 \cdot 2,
\\
&=
2.
\end{align*}
\end{example}

\begin{problem}{modular:big.power}
Compute \(2^{100}\) modulo \(125\).
\end{problem}


\section{Reciprocals}

Every nonzero rational number \(b/c\) has a reciprocal: \(c/b\).
Since we now have modular arithmetic defined, we want to know which remainders have ``reciprocals''.
Working modulo some positive integer, say that a remainder \(x\) has a reciprocal \(y=x^{-1}\) if \(xy=1\).
(It seems just a little too weird to write it as \(y=1/x\), but you can if you like.)
Reciprocals are also called \emph{multiplicative inverses}.\define{multiplicative inverse}
\begin{example}
Modulo \(7\)
\begin{align*}
\bar{1} \cdot \bar{1} &= \bar{1}, \\
\bar{2} \cdot \bar{4} &= \bar{1}, \\
\bar{3} \cdot \bar{5} &= \bar{1}, \\
\bar{4} \cdot \bar{2} &= \bar{1}, \\
\bar{5} \cdot \bar{3} &= \bar{1}, \\
\bar{6} \cdot \bar{6} &= \bar{1}.
\end{align*}
So in this weird type of arithmetic, we can allow ourselves the freedom to write these equations as identifying a reciprocal.
\begin{align*}
\bar{1}^{-1} &= \bar{1}, \\
\bar{2}^{-1} &= \bar{4}, \\
\bar{3}^{-1} &= \bar{5}, \\
\bar{4}^{-1} &= \bar{2}, \\
\bar{5}^{-1} &= \bar{3}, \\
\bar{6}^{-1} &= \bar{6}.
\end{align*}
\end{example}
A remainder that has a reciprocal is a \emph{unit}.\define{unit}

\begin{problem}{modular.arithmetic:no.reciprocal}
\emph{Danger:} If we work modulo \(4\), then prove that \(\bar{2}\) has \emph{no} reciprocal.
Hint: \(\bar{2}^2=0\).
\end{problem}

\begin{problem}{modular.arithmetic:reciprocal}
Prove that, modulo any integer \(m\), \((m-1)^{-1}=m-1\), and that modulo \(m^2\), \((m-1)^{-1}=m^2-m-1\).
\end{problem}

\begin{theorem}
Take a positive integer \(m\) and a remainder \(\bar{r}\) modulo \(m\).
Take the B\'ezout coefficients of \(r\) and \(m\): \(sr+tm=d\), so that \(d\) is the greatest common divisor of \(r\) and \(m\).

If \(d=1\) then \(\bar{r}^{-1}=\bar{s}\) modulo \(m\).
If \(d \ne 1\) then \(\bar{r}^{-1}\) does not exist.
In particular, in the remainders modulo \(m\), a remainder \(\bar{r}\) is a unit just when \(r,m\) are coprime integers.
\end{theorem}
\begin{proof}
If \(r,m\) are coprime integers, so their greatest common divisor is \(1\), then write B\'ezout coefficients \(sr+tm=1\), and quotient by \(m\):
\[
\bar{s}\bar{r}=\bar{1}.
\]

On the other hand, if 
\[
\bar{s}\bar{r}=\bar{1},
\]
then \(sr\) is congruent to \(1\) modulo \(m\), i.e. there is some quotient \(q\) so that \(sr=qm+1\), so \(sr-qm=1\), giving B\'ezout coefficients \(s=s,t=-q\), so the greatest common divisor of \(r,m\) is \(1\).
\end{proof}

\begin{example}
Working modulo \(163\), let's compute \(14^{-1}\).
First we carry out the long division
\[
\longdiv{163}{14}
\]
Now let's start looking for B\'ezout coefficients, by writing out matrix:
\[
\begin{pmatrix}
1 & 0 & 14 \\
0 & 1 & 163
\end{pmatrix}
\]
and then add \(-11\cdot\text{row 1}\) to row 2:
\[
\begin{pmatrix}
1 & 0 & 14 \\
-11 & 1 & 9
\end{pmatrix}.
\]
Add \(-\text{row 2}\) to row 1:
\[
\begin{pmatrix}
12 & -1 & 5 \\
-11 & 1 & 9
\end{pmatrix}.
\]
Add \(-\text{row 1}\) to row 2:
\[
\begin{pmatrix}
12 & -1 & 5 \\
-23 & 2 & 4
\end{pmatrix}.
\]
Add \(-\text{row 2}\) to row 1:
\[
\begin{pmatrix}
35 & -3 & 1 \\
-23 & 2 & 4
\end{pmatrix}.
\]
Add \(-4 \cdot \text{row 1}\) to row 2:
\[
\begin{pmatrix}
35 & -3 & 1 \\
-163 & 14 & 0
\end{pmatrix}.
\]
Summing it all up: \(35 \cdot 14 + (-3) \cdot 163 = 1\).
Quotient out by \(163\): modulo \(163\), \(35 \cdot 14 = 1\), so modulo \(163\), \(14^{-1}=35\).
\end{example}

\begin{problem}{modular.arithmetic:reciprocals}
Use this method to find reciprocals:
\begin{enumerate}
\item 
\(13^{-1}\) modulo \(59\)
\item
\(10^{-1}\) modulo \(11\)
\item
\(2^{-1}\) modulo \(193\).
\item
\(6003722857^{-1}\) modulo \(77695236973\).
\end{enumerate}
\end{problem}
\begin{answer}{modular.arithmetic:reciprocals}
\begin{enumerate}
\item 
\sagestr{bezpretty(13,59)}
Answer:\(13^{-1} = \sage{inverse_mod(13,59)}\) modulo \(59\)
\item
\sagestr{bezpretty(10,11)}
Answer:\(10^{-1} = \sage{inverse_mod(10,11)}\) modulo \(11\)
\item
\sagestr{bezpretty(2,193)}
Answer:\(2^{-1} = \sage{inverse_mod(2,193)}\) modulo \(193\)
\item
\sagestr{bezpretty(6003722857,77695236973)}
Answer:\(6003722857^{-1} = \sage{inverse_mod(6003722857,77695236973)}\) modulo \(77695236973\)
\end{enumerate}
\end{answer}

\begin{problem}{modular.arithmetic:prime.field}
Suppose that \(b, c\) are remainders modulo a prime.
Prove that \(bc=0\) just when either \(b=0\) or \(c=0\).
\end{problem}

\begin{problem}{modular.arithmetic:Fermats.Little.Theorem}
Suppose that \(p\) is a prime number and \(n\) is an integer with \(n < p\).
Explain why, modulo \(p\), the numbers \(0, n, 2n, 3n, \dots, (p-1)n\) consist in precisely the remainders \(0,1,2,\dots,p-1\), in some order.
(Hint: use the reciprocal of \(n\).)
Next, since every nonzero remainder has a reciprocal remainder, explain why the product of the nonzero remainders is \(1\).
Use this to explain why 
\[
\congmod[p]{n^{p-1}}{1}.
\]
Finally, explain why, for any integer \(k\),
\[
\congmod[p]{k^p}{k}.
\]
\end{problem}

\section{The Chinese remainder theorem}

\epigraph[author={Brahmagupta (580CE--670CE)}, source={Brahma-Sphuta-Siddhanta (Brahma's Correct System)}]{An old woman goes to market and a horse steps on her basket and  crushes the eggs. The rider offers to pay for the damages and asks  her how many eggs she had brought. She does not remember the 
exact number, but when she had taken them out two at a time,  there was one egg left. The same happened when she picked them out three, four, five, and six at a time, but when she took them seven at a time, there were none left. What is the smallest number of eggs she could have had?}\SubIndex{Brahmagupta}\SubIndex{Brahma-Sphuta-Siddhanta}\SubIndex{Brahma's correct system}

Take a look at some numbers and their remainders modulo \(3\) and \(5\):
\[
\begin{array}{@{}rrr@{}}
\toprule
n & n \operatorname{mod} 3 & n \operatorname{mod} 5 \\ \midrule
0 & 0 & 0 \\
1 & 1 & 1 \\
2 & 2 & 2 \\
3 & 0 & 3 \\
4 & 1 & 4 \\
5 & 2 & 0 \\
6 & 0 & 1 \\
7 & 1 & 2 \\
8 & 2 & 3 \\
9 & 0 & 4 \\
10 & 1 & 0 \\
11 & 2 & 1 \\
12 & 0 & 2 \\
13 & 1 & 3 \\
14 & 2 & 4 \\
15 & 0 & 0 \\
\bottomrule
\end{array}
\]
Remainders modulo \(3\) repeat every \(3\), and remainders modulo \(5\) repeat every \(5\), but the pair of remainders modulo \(3\) and \(5\) together repeat every \(15\).

\begin{example}
How can you find an integer \(x\) so that 
\begin{align*}
&\congmod[3]{x}{1}, \\
&\congmod[4]{x}{2}, \\
&\congmod[7]{x}{1}?
\end{align*}
\end{example}

\begin{example}
A recipe: how to find an unknown integer \(x\) given only the knowledge of its remainders modulo various integers.
Suppose we know \(x\) has remainder \(r_1\) modulo \(m_1\), \(r_2\) modulo \(m_2\), and so on.
Let 
\[
m\defeq m_1 m_2 \dots m_n.
\]
For each \(i\), let
\[
u_i\defeq \frac{m}{m_i}=m_1 m_2 \dots m_{i-1} m_{i+1} m_{i+2} \dots m_n.
\]
Each \(u_i\) has some reciprocal modulo \(m_i\), given as the remainder of some integer \(v_i\).
Let 
\[
x\defeq r_1 u_1 v_1 + r_2 u_2 v_2 + \dots + r_n u_n v_n.
\]
We can simplify this a little: add or subtract multiples of \(m\) until \(x\) is in the range \(0 \le x \le m-1\).
\end{example}

\begin{theorem}
Take some positive integers \(m_1, m_2, \dots, m_n\), so that any two of them are coprime.
Suppose that we want to find an unknown integer \(x\) given only the knowledge of its remainders modulo \(m_1, m_2, \dots, m_n\); so we know its remainder modulo \(m_1\) is \(r_1\), modulo \(m_2\) is \(r_2\), and so on.
There is such an integer \(x\), given by the recipe above, and \(x\) is unique modulo 
\[
m_1 m_2 \dots m_n.
\]
\end{theorem}
\begin{proof}
All of \(m_1, m_2, \dots, m_n\) divide \(u_i\), except \(m_i\).
So if \(j \ne i\) then modulo \(m_j\), \(u_i=0\).
All of the other \(m_j\) are coprime to \(m_i\), so their product is coprime to \(m_i\), so has a reciprocal modulo \(m_i\).
Thus modulo \(m_i\), \(u_i\ne 0\). 
Then modulo \(m_i\), \(x=r_i\), and so on.
So the recipe gives the required integer \(x\).
If there are two, then their difference vanishes modulo all of the \(m_i\), so is a multiple of every one of the \(m_i\), which are coprime, so is a multiple of their product \(m\).
\end{proof}

\begin{example}
Let's find an integer \(x\) so that 
\begin{align*}
&\congmod[3]{x}{1}, \\
&\congmod[4]{x}{2}, \\
&\congmod[7]{x}{1}.
\end{align*}
So in this problem we have to work modulo \(\pr{m_1,m_2,m_3}=\pr{3,4,7}\), and get remainders \(\pr{r_1,r_2,r_3}=\pr{1,2,1}\).
First, no matter what the remainders, we have to work out the reciprocal mod each \(m_i\) of the product of all of the other \(m_j\).
So let's reduce these products down to their remainders:
\begin{align*}
4 \cdot 7 &= 28 = 9\cdot 3 + 1 \equiv 1 \pmod{3}, \\
3 \cdot 7 &= 21 = 5\cdot 4 + 1 \equiv 1 \pmod{4}, \\
3 \cdot 4 &= 12 = 1\cdot 7 + 5 \equiv 5 \pmod{7}.
\end{align*}
We need the reciprocals of these, which, to save ink, we just write down for you without writing out the calculations:
\begin{align*}
1^{-1} &\equiv 1 \pmod{3}, \\
1^{-1} &\equiv 1 \pmod{4}, \\
5^{-1} &\equiv 3 \pmod{7}.
\end{align*}
(You can easily check those.)
Finally, we add up remainder times product times reciprocal:
\begin{align*}
x
&=
r_1 \cdot 4 \cdot 7 \cdot 1 
+
r_2 \cdot 3 \cdot 7 \cdot 1 
+
r_3 \cdot 3 \cdot 4 \cdot 3,
\\
&=
1 \cdot 4 \cdot 7 \cdot 1 
+
2 \cdot 3 \cdot 7 \cdot 1 
+
1 \cdot 3 \cdot 4 \cdot 3,
\\
&=
106.
\end{align*}
We can now check to be sure:
\begin{align*}
&\congmod[3]{106}{1}, \\
&\congmod[4]{106}{2}, \\
&\congmod[7]{106}{1}.
\end{align*}
The Chinese remainder theorem tells us also that \(106\) is the unique solution modulo \(3 \cdot 4 \cdot 7=84\).
But then \(106-84=22\) is also a solution, the smallest positive solution.
\end{example}

\begin{problem}{modular.arithmetic:eggs}
Solve the problem about eggs. Hint: ignore the information about eggs taken out six at a time.
\end{problem}

\begin{problem}{modular.arithmetic:army}
Use the Chinese remainder theorem to determine the smallest number of soldiers possible in Han Xin's army if the following facts are true.
When they parade in rows of 3 soldiers, two soldiers will be left. When they parade in rows of 5, 3 will be left, and in rows of 7, 2 will be left.
\end{problem}

\begin{problem}{modular.arithmetic:army.2}
Use the Chinese remainder theorem to determine the smallest number of soldiers possible in Han Xin's army if the following facts are true.
When they parade in rows of 3 soldiers, one soldier will be left. When they parade in rows of 7, 2 will be left, and in rows of 19, three will be left.
\end{problem}
\begin{answer}{modular.arithmetic:army.2}
We want to find remainders \((1,2,3)\) modulo \((3,7,19)\).
We let 
\begin{align*}
u_1 &= 7 \cdot 19 = 133, \\
u_2 &= 3 \cdot 19 = 57, \\
u_3 &= 3 \cdot 7 = 21.
\end{align*}
Modulo \(3,7,19\) these are
\begin{align*}
u_1 &= 1 \mod{3}, \\
u_2 &= 1 \mod{7}, \\
u_3 &= 2 \mod{19}.
\end{align*}
The multiplicative inverses of these, modulo \(3,7,19\), are obvious by reducing and inspection:
\begin{align*}
v_1 &= 1, \\
v_2 &= 1, \\
v_3 &= 10.
\end{align*}
By the Chinese remainder theorem, the answer, up to multiples of \(3 \cdot 7 \cdot 19=399\), is
\begin{align*}
r_1 u_1 v_1 + r_2 u_2 v_2 + r_3 u_3 v_3 
&=
1 \cdot 133 \cdot 1 
+
2 \cdot 57 \cdot 1
+
3 \cdot 21 \cdot 10,
\\
&=
133+114+630,
\\
&=877,
\\
&=79+2 \cdot 399.
\end{align*}
So there are at least 79 soldiers in Han Xin's army.
\end{answer}


Given some integers \(m_1, m_2, \dots, m_n\), we consider sequences \(\pr{b_1, b_2, \dots, b_n}\) consisting of remainders: \(b_1\) a remainder modulo \(m_1\), and so on.
Add sequences of remainders in the obvious way:
\[
\pr{b_1,b_2,\dots,b_n}
+
\pr{c_1,c_2, \dots, c_n}
=
\pr{b_1+c_1,b_2+c_2, \dots, b_n+c_n}.
\]
Similarly, we can subtract and multiply sequences of remainders:
\[
\pr{b_1,b_2,\dots,b_n}
\pr{c_1,c_2, \dots, c_n}
=
\pr{b_1c_1,b_2c_2, \dots, b_nc_n},
\]
by multiplying remainders as usual, modulo the various \(m_1, m_2, \dots, m_n\).
\begin{example} 
Modulo \(\pr{3,5}\), we multiply 
\begin{align*}
(2,4)(3,2)
&=(2 \cdot 3, 4 \cdot 2),
\\
&=(6, 8),
\\
&=(0,3).
\end{align*}
\end{example}

Let \(m \defeq m_1 m_2 \dots m_n\).
To each remainder modulo \(m\), say \(b\), associate its remainder \(b_1\) modulo \(m_1\), \(b_2\) modulo \(m_2\), and so on.
Associate the sequence \(\vec{b}\defeq\pr{b_1,b_2,\dots,b_n}\) of all of those remainders.
In this way we make a map taking each remainder \(b\) modulo \(m\) to its sequence \(\vec{b}\) of remainders modulo all of the various \(m_i\).
Moreover, \(\overrightarrow{b+c}=\vec{b}+\vec{c}\) and \(\overrightarrow{b-c}=\vec{b}-\vec{c}\) and \(\overrightarrow{bc}=\vec{b}\vec{c}\), since each of these works when we take remainder modulo anything.

\begin{example}
Take \(m_1,m_2,m_3\) to be \(3,4,7\).
Then \(m=3 \cdot 4 \cdot 7 = 84\).
If \(b=8\) modulo \(84\), then 
\begin{align*}
b_1 &= 8 \mod 3, \\
    &= 2, \\
b_2 &= 8 \mod 4, \\
    &= 0, \\
b_3 &= 8 \mod 7, \\
    &= 1, \\
\vec{b} &= \pr{b_1,b_2,b_3} = \pr{2,0,1}.  
\end{align*}
\end{example}


\begin{corollary}\label{corollary:CRT}
Take some positive integers \(m_1, m_2, \dots, m_n\), so that any two of them are coprime.
The map taking \(b\) to \(\vec{b}\), from remainders modulo \(m\) to sequences of remainders modulo \(m_1, m_2, \dots, m_n\), is one-to-one and onto, identifies sums with sums, products with products, differences with differences, units with sequences of units.
\end{corollary}


\section{Euler's totient function}

\emph{Euler's totient function}\define{Euler's totient function}\define{totient function} \(\phi\)\Notation{phi(m)}{\phi(m)}{Euler's totient function} assigns to each positive integer \(m=2,3, \dots\) the number of all remainders modulo \(m\) which are units (in other words, coprime to \(m\)) [in other words, which have reciprocals].
It is convenient to \emph{define} \(\phi(1)\defeq 1\) (even though there \emph{isn't} actually 1 unit remainder modulo 1).

\begin{problem}{modular.arithmetic:totient.values}
Explain by examining the remainders that the first few values of \(\phi\) are
\[
\begin{array}{@{}rl@{}}
\toprule
m & \phi(m) \\
\midrule
1 & 1 \\
2 & 1 \\
3 & 2 \\
4 & 2 \\
5 & 4 \\
6 & 2 \\
7 & 6 \\
\bottomrule
\end{array}
\]
\end{problem}

\begin{problem}{modular.arithmetic:prime.phi}
Prove that a positive integer \(m \ge 2\) is prime just when \(\phi(m)=m-1\).
\end{problem}

\begin{theorem}\label{theorem:totient}
Suppose that \(m\ge 2\) is an integer with prime factorizaton
\[
m = p_1^{a_1} p_2^{a_2} \dots p_n^{a_n},
\]
so that \(p_1, p_2, \dots, p_n\) are prime numbers and \(a_1, a_2, \dots, a_n\) are positive integers.
Then
\[
\phi(m)=
\pr{p_1^{a_1}-p_1^{a_1-1}}
\pr{p_2^{a_2}-p_2^{a_2-1}}
\dots
\pr{p_n^{a_n}-p_n^{a_n-1}}.
\]
\end{theorem}
\begin{proof}
If \(m\) is prime, this follows from problem~\vref{problem:modular.arithmetic:prime.phi}.

Suppose that \(m\) has just one prime factor, or in other words that \(m=p^a\) for some prime number \(p\) and integer \(a\).
It is tricky to count the remainders coprime to \(m\), but easier to count those not coprime, i.e. those which have a factor of \(p\).
Clearly these are the multiples of \(p\) between \(0\) and \(p^a-p\), so the numbers \(pj\) for \(0 \le j \le p^{a-1}-1\).
So there are \(p^{a-1}\) such remainders.
We take these out and we are left with \(p^a-p^{a-1}\) remainders left, i.e. coprime.

If \(b,c\) are coprime integers \(\ge 2\), then corollary~\vref{corollary:CRT} maps units modulo \(bc\) to pairs of a unit modulo \(b\) and a unit modulo \(c\), and is one-to-one and onto.
Therefore counting units: \(\phi(bc)=\phi(b)\phi(c)\).
\end{proof}

\begin{theorem}[Euler]\label{theorem:Euler}
For any positive integer \(m\) and any integer \(b\) coprime to \(m\), 
\[
\congmod[m]{b^{\phi(m)}}{1}.
\]
\end{theorem}
\begin{proof}
Working with remainders modulo \(m\), we have to prove that for any unit remainder \(b\), \(b^{\phi(m)}=1\) modulo \(m\).

Let \(U\) be the set of all units modulo \(m\), so \(U\) is a subset of the remainders \(0,1,2,\dots,m-1\).
The product of units is a unit, since it has a reciprocal (the product of the reciprocals).
Therefore the map
\[
u \in U \mapsto bu \in U
\]
is defined.
It has an inverse:
\[
u \in U \mapsto b^{-1}u \in U,
\]
where \(b^{-1}\) is the reciprocal of \(b\).
Writing out the elements of \(U\), say as
\[
u_1, u_2, \dots, u_q
\]
note that \(q=\phi(m)\).
Then multiplying by \(b\) scrambles these units into a different order:
\[
bu_1, bu_2, \dots, bu_q.
\]
But multiplying by \(b\) just scrambles the order of the roots, so if we multiply them all, and then scramble them back into order:
\[
\pr{bu_1}\pr{bu_2} \dots \pr{bu_q}= u_1 u_2 \dots u_q.
\]
Divide every unit \(u_1, u_2, \dots, u_q\) out of boths sides to find \(b^q=1\).
\end{proof}

\begin{problem}{modular.arithmetic:find.reciprocal}
Take an integer \(m \ge 2\).
Suppose that \(b\) is a unit in the remainders modulo \(m\).
Prove that the reciprocal of \(b\) is \(b^{\phi(m)-1}\).
\end{problem}

Euler's theorem is important because we can use it to calculate quickly modulo prime numbers (and sometimes even modulo numbers which are not prime).
\begin{example}
Modulo \(19\), let's find \(123456789^{987654321}\).
First, the base of this expression is \(123456789=6497725 \cdot 19 + 14\)
So modulo \(19\):
\[
123456789^{987654321}=14^{987654321}.
\]
That helps with the base, but the exponent is still large.
According to Euler's theorem, since \(19\) is prime, modulo \(19\):
\[
b^{19-1} = 1
\]
for any remainder \(b\).
In particular, modulo \(19\),
\[
14^{18}=1.
\]
So every time we get rid of \(18\) copies of \(14\) multiplied together, we don't change our result. 
Divide \(18\) into the exponent:
\[
987654321 = 54869684 \cdot 18 + 9.
\]
So then modulo \(19\):
\[
14^{987654321} = 14^9.
\]
We leave the reader to check that \(14^9=18\) modulo \(19\), so that finally, modulo \(19\),
\[
123456789^{987654321}=18.
\]
\end{example}

\begin{problem}{modular:use.totient}
By hand, using Euler's totient function, compute \(127^{162}\) modulo \(120\).
\end{problem}
\begin{answer}{modular:use.totient}
Factor \(120 =2^3 \, 3^1 \, 5^1\).
So Euler's totient is \(\phi(120)=(2^3-2^2)(3^1-3^0)(5^1-5^0)=32\).
Since \(127\) is prime, it is coprime to \(120\).
The theorem of Euler's totient function says that \(127^{\phi(120)}=1\) modulo \(120\). 
So \(127^{32}=1\) modulo \(120\).
In other words, every time you multiply together \(32\) copies of \(127\), modulo \(120\), it is as if you multiplied together no copies.
Check that \(162 = 5\cdot 32+2\).
So modulo 120, \(127^{162}=127^{5 \cdot 32+2}=127^2\). 
This is not quite the answer. 
But we know that \(127=7\) modulo \(120\). 
So modulo 120, \(127^{162}=7^2=49\).
\end{answer}

\begin{lemma}\label{lemma:multiply.by.a}
For any prime number \(p\) and integers \(b\) and \(k\), \(b^{1+k(p-1)}=b\) modulo \(p\).
\end{lemma}
\begin{proof}
If \(b\) \emph{is} a multiple of \(p\) then \(b=0\) modulo \(p\) so both sides are zero. 
If \(b\) is not a multiple of \(p\) then \(b^{p-1}=1\) modulo \(p\), by Euler's theorem.
Take both sides to the power \(k\) and multiply by \(b\) to get the result.
\end{proof}

\begin{theorem}\label{theorem:generalized.Euler}
Suppose that \(m=p_1 p_2 \dots p_n\) is a product of distinct prime numbers.
Then for any integers \(b\) and \(k\) with \(k \ge 0\),
\[
\congmod[m]{b^{1+k\phi(m)}}{b}.
\]
\end{theorem}
\begin{proof}
By lemma~\vref{lemma:multiply.by.a}, the result is true if \(m\) is prime.
So if we take two prime numbers \(p\) and \(q\), then\(b^{1+k(p-1)(q-1)}=b\) modulo \(p\), but also modulo \(q\), and therefore modulo \(pq\).
The same trick works if we start throwing in more distinct prime factors into \(m\).
\end{proof}

\begin{problem}{modular.arithmetic:example.not.Euler}
Give an example of integers \(b\) and \(m\) with \(m \ge 2\) for which \(b^{1+\phi(m)} \ne b\) modulo \(m\).
\end{problem}


\section{Sage}

In Sage, the quotient of \(71\) modulo \(13\) is \verb!mod(71,13)!.
The tricky bit: it returns a ``remainder modulo 13'', so if we write
\begin{sageblock}
a=mod(71,13)
\end{sageblock}
this will define \(a\) to be a ``remainder modulo 13''. 
The value of \(a\) is then \(\sage{a}\), but the value of \(a^2\) is \(\sage{a^2}\), because the result is again calculated modulo 13.

Euler's totient function is
\begin{sageblock}
euler_phi(777)
\end{sageblock}
which yields \(\phi(777)=\sage{euler_phi(777)}\).
To find \(14^{-1}\) modulo \(19\),
\begin{sageblock}
inverse_mod(14,19)
\end{sageblock}
yields
\(14^{-1}=\sage{inverse_mod(14,19)}\) modulo \(19\).

We can write our own version of Euler's totient function, just to see how it might look:
\begin{sageblock}
def phi(n):
    return prod(p^a-p^(a-1) for (p,a) in factor(n))
\end{sageblock}
where \verb!prod! means product, so that \verb!phi(666)! yields \(\phi(666)=\sage{phi(666)}\).
The code here uses the function \verb!factor()!, which takes an integer \(n\) and returns a list \verb!p=factor(n)! of its prime factors.
In our case, the prime factorisation of \(666\) is \(666=2 \cdot 3^2 \cdot 37\).
The expression \verb!p=factor(n)! when \(n=666\) yields a list \verb!p=[(2,1), (3,2), (37,1)]!, a list of the prime factors together with their powers.
To find these values, \verb!p[0]! yields \verb!(2,1)!, \verb!p[1]! yields \verb!(3,2)!, and \verb!p[2]! yields \verb!(37,1)!.
The expression \verb!len(p)! gives the length of the list \verb!p!, which is the number of entries in that list, in this case \(3\).
For each entry, we set \(b=p_i\) and \(e=a_i\) and then multiply the result \(r\) by \(b^e-b^{e-1}\).

To use the Chinese remainder theorem, suppose we want to find a number \(x\) so that \(x\) has remainders \(1\) mod \(3\) and \(2\) mod \(7\),
\begin{sageblock}
crt([1,2],[3,7])
\end{sageblock}
gives you \(x=\sage{crt([1,2],[3,7])}\); you first list the two remainders \verb!1,2! and then list the moduli \verb!3,7!.

Another way to work with modular arithmetic in sage: we can create an object which represents the remainder of \(9\) modulo \(17\):
\begin{sageblock}
a=mod(9,17)
a^(-1)
\end{sageblock}
yielding \(\sage{a^(-1)}\).
As long as all of our remainders are modulo the same number \(17\), we can do arithmetic directly on them:
\begin{sageblock}
b=mod(7,17)
a*b
\end{sageblock}
yields \(\sage{a*b}\).


